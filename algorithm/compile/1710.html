<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>

</body>

</html>
<script>
	"use strict"

	const nullStack = [];
	const firstStack = [];
	const lastStack = [];
	const followMap = [];
	const flagStack = [];
	const letterMap = {};
	let integrate = true;

	function starProcess() {
		nullStack.pop();
		nullStack.push(true);
		lastStack[lastStack.length - 1].forEach(j => {
			if (!followMap[j]) {
				followMap[j] = [];
			}
			[].push.apply(followMap[j], firstStack[firstStack.length - 1] || []);
		});
	}
	function alternateProcess() {
		let right = nullStack.pop();
		let left = nullStack.pop();
		nullStack.push(left || right);

		right = firstStack.pop();
		left = firstStack.pop();
		firstStack.push(left.concat(right));

		right = lastStack.pop();
		left = lastStack.pop();
		lastStack.push(left.concat(right));
		flagStack.pop();
	}

	function concateProcess() {
		if (nullStack.length < 2) return;
		let right = nullStack.pop();
		let left = nullStack.pop();
		nullStack.push(left && right);

		let rightFirst = firstStack.pop();
		let leftFirst = firstStack.pop();

		firstStack.push(left ? leftFirst.concat(rightFirst) : leftFirst);

		let rightLast = lastStack.pop();
		let leftLast = lastStack.pop();
		lastStack.push(right ? leftLast.concat(rightLast) : rightLast);

		leftLast.forEach(j => {
			if (!followMap[j]) {
				followMap[j] = [];
			}
			[].push.apply(followMap[j], rightFirst || []);
		});

	}

	function parseExpr(str) {

		for (let i = 0, k = 0; i < str.length; i++) {

			switch (str[i]) {
				case '|':
					if (flagStack[flagStack.length - 1] == '|') {
						alternateProcess();
					}
					flagStack.push('|');
					integrate = true;
					break;

				case '(':
					flagStack.push('(');
					integrate = true;
					break;

				case ')':
					if (flagStack[flagStack.length - 1] == '|') {
						alternateProcess();
					}
					flagStack.pop(); //弹出 (

					if (str[i + 1] == '*') {
						starProcess();
						i++;
					}
					if (!integrate) {
						concateProcess();
					}
					integrate = false;

					break;

				default:
					k++;
					if (!letterMap[str[i]]) {
						letterMap[str[i]] = [];
					}
					letterMap[str[i]].push(k);

					nullStack.push(false);
					firstStack.push([k]);
					lastStack.push([k]);
					if (str[i + 1] == '*') {
						starProcess();
						i++;
					}
					if (!integrate) {
						concateProcess();
					}
					integrate = false;
					break;
			}
		}

	}
	const map = {};
	let index = 0;

	function hash(array) {
		const key = array.reduce((total, current) => {
			return total + String(current) + ',';
		}, '');
		return map[key] || (map[key] = ++index);
	}
	function buildDFA(str) {
		parseExpr(str + '#');
		const dfa = {};
		const states = [firstStack.pop()];
		const transTable = {};
		for (let n = 0; n < states.length; n++) {
			// return;
			const list = states[n];
			Object.keys(letterMap).forEach(i => {
				let group = letterMap[i].filter(j => list.includes(j));
				if (i == '#' && group.length) {
					if (!dfa.accept) {
						dfa.accept = [];
					}
					dfa.accept.push(...group);
					return;
				};
				let resGroup = group.reduce((total, current) => {
					return [...new Set(total.concat(followMap[current]))];
				}, []);
				if (states.every((t) => t.concat(resGroup).reduce((total, j) => {
					return total ^ j;
				}, 0) != 0)) {
					states.push(resGroup);
				}
				if (resGroup.length == 0) return;
				let key = hash(list);
				if (!transTable[key]) {
					transTable[key] = {};
				}
				transTable[key][i] = hash(resGroup);

			});
		}
		dfa.symbols = Object.keys(letterMap);
		dfa.states = Object.values(map);
		dfa.transTable = transTable;
		dfa.start = hash(states[0]);
		dfa.accept = dfa.accept.reduce((total, current) => {
			return [...new Set(Object.keys(map).filter(j => j.includes(String(current))).map(i => map[i]).concat(total))];
		}, []);
		dfa.accept.map(i => Object.keys(map).filter(j => j.includes(String(i))));
		return dfa;
	}
	const dfa = buildDFA("(a|b)*abb");

	function divideEqual(array1, array2) {
		for (let i = 0; i < array1.length; i++) {
			const index = array2.findIndex(j => j.includes(array1[i][0]));
			if (!array2.every(j => j.every(k => array[i].includes(k)))) {
				return false;
			}
		}
		return true;
	}

	function statesMinimize(dfa) {
		const nonAccept = dfa.states.filter(i => !dfa.accept.includes(i));
		const symbols = dfa.symbols.slice(0, -1);
		let divide = [
			dfa.accept,
			nonAccept
		];
		let newDivide = [
			dfa.accept,
			nonAccept
		];
		while (!divideEqual(devide, newDivide)) {
			let group = [];
			for (let i = 0; i < divide.length; i++) {
				if (divide[i].length < 2) continue;

				let state = divide[i][0];
				const to = dfa.transTable[state][symbols[k]];
				const index = divide.findIndex(i => i.includes(to));
				group[index] = index;

				for (let j = 1; j < divide[i].length; j++) {
					for (let k = 0; k < symbols.length; k++) {
						let state = divide[i][j];
						const to = dfa.transTable[state][symbols[k]];
						const index = divide.findIndex(i => i.includes(to));
						const nIndex = newDivide.findIndex(i => i.includes(state));
						newDivide[nIndex].splice(newDivide[nIndex].indexOf(state));
						if (!group[index]) {
							newDivide.push([state]);
							group[index] = newDivide.length - 1;
						} else {
							newDivide[group[index]].push(state);
						}
					}
				}
			}
		}
	}
</script>